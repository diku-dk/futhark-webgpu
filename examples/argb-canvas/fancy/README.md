# Fancy (ARGB u32 → HTML canvas)

This example renders a more complex test image (HSV-style color wheel with alpha and a subtle overlay) and displays it in a browser canvas twice:

- **Raw**: writes packed `u32` pixels directly into the canvas buffer (usually wrong).
- **Fixed**: applies an ARGB → canvas conversion before drawing (correct).

The goal is to verify that the conversion works not just for pure red/green/blue, but for "real" colors and transparency.

## What you should see

You should see a circular rainbow / color-wheel style pattern with fading alpha.

- In **Raw**, the colors will typically look "off" (commonly red/blue swapped).
- In **Fixed**, the colors should look natural (expected rainbow order), and alpha should fade smoothly.

## Files

- `fancy.fut`
  Generates an image as `[]u32` where each element is a packed pixel:

  - format (by convention in this example): **ARGB**
    ```
    0xAARRGGBB
    ```

  Entry point:
  - `entry render(w: i32, h: i32) -> []u32`

- `index.html`
  Page layout: status panel + two canvases (Raw/Fixed) and simple controls (width/height, conversion toggle).

- `main.js`
  The glue code. This is where the important part happens:
  - initializes the generated WebGPU/WASM runtime
  - calls `fut.entry.render(w, h)` to compute pixels
  - reads the result back into JS (`await buf.values()`)
  - draws the pixels to the two canvases
  - applies the conversion for the "Fixed" canvas

- `Makefile`
  Builds the WebGPU library output and starts a simple local server.

- Generated files from `futhark webgpu --library` (not committed):
  - `fancy.js`, `fancy.wasm`, `fancy.json`, `fancy.wrapper.js`, ...

## How `main.js` works

1. **Load the generated module**
   `fancy.js` (generated by Futhark) provides:
   - `Module()` (Emscripten/WASM loader)
   - `FutharkModule` (JS wrapper for calling entry points)

2. **Call the Futhark entry point**

   `buf.values()` copies the output back into JS as a `Uint32Array`.
   `buf.free()` is important to avoid leaking GPU/WASM resources.

3. **Draw Raw**
   Raw drawing makes a `Uint32Array` view of the canvas `ImageData` buffer and copies the words in directly.
   This is the fast path, but it only works if the word format matches what the canvas expects.

4. **Draw Fixed**
   For the fixed canvas, we convert each pixel from ARGB to the word format that produces RGBA bytes in `ImageData`.

   On almost all machines (little-endian), that conversion is effectively:

   * swap red and blue: `0xAARRGGBB` → `0xAABBGGRR` (ABGR word)

   The result is then blitted via the same `Uint32Array(ImageData.data.buffer)` fast path.

5. **Conversion toggle**
   The checkbox controls whether the conversion step is applied for the "Fixed" canvas.
   Turning it off makes both canvases use the raw path.
