async function run() {
  const statusEl = document.getElementById("status");
  const cRaw = document.getElementById("cRaw");
  const cFixed = document.getElementById("cFixed");

  const sourceEl = document.getElementById("source");
  const renderBtn = document.getElementById("renderBtn");
  const autoRenderEl = document.getElementById("autoRender");

  const w = 256;
  const h = 64;

  function log(line) {
    statusEl.textContent += line + "\n";
    statusEl.parentElement.scrollTop = statusEl.parentElement.scrollHeight;
  }
  function clearLog() {
    statusEl.textContent = "";
  }

  // ---------- Endianness + conversions ----------
  function isLittleEndian() {
    const b = new ArrayBuffer(4);
    new Uint32Array(b)[0] = 0x01020304;
    return new Uint8Array(b)[0] === 0x04; // check if least significant byte is at lowest address
  }
  const little = isLittleEndian();

  // ARGB (0xAARRGGBB) -> ABGR (0xAABBGGRR): swap R and B
  function argbToAbgr(x) {
    x = x >>> 0; // ensure unsigned
    return (
      (x & 0xFF00FF00) | // keep A and G
      ((x & 0x00FF0000) >>> 16) | // R -> B
      ((x & 0x000000FF) << 16) // B -> R
    ) >>> 0;
  }

  // ARGB (AARRGGBB) -> RGBA (RRGGBBAA): rotate left by 8 bits
  function argbToRgbaBE(x) {
    x = x >>> 0;
    return ((x << 8) | (x >>> 24)) >>> 0; // 24 because we want to move A from MSB to LSB
  }

  // What word value should we write into Uint32Array(ImageData.data.buffer)
  // so that the underlying bytes become RGBA?
  //
  // - little-endian: word must look like ABGR (AABBGGRR)
  // - big-endian:    word must look like RGBA (RRGGBBAA)
  function argbToCanvasWord(x) {
    return little ? argbToAbgr(x) : argbToRgbaBE(x);
  }

  // ---------- Drawing ----------
  function drawU32(canvas, pixelsU32, w, h) {
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d", { alpha: true });
    const img = ctx.createImageData(w, h);
    const dst = new Uint32Array(img.data.buffer);
    dst.set(pixelsU32);
    ctx.putImageData(img, 0, 0);
  }

  // ---------- JS generator (ARGB packed u32) ----------
  function makeARGBStripes(w, h) {
    const out = new Uint32Array(w * h);
    const colors = [
      0xFFFF0000, // red   (AARRGGBB)
      0xFF00FF00, // green
      0xFF0000FF, // blue
      0xFFFFFFFF, // white
    ];
    const stripeW = (w / 4) | 0;

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const s = Math.min(3, (x / stripeW) | 0); // s represents the stripe index (0-3) 
        out[y * w + x] = colors[s] >>> 0;
      }
    }
    return out;
  }

  // ---------- JS generator (already canvas word format) ----------
  function makeABGRStripes(w, h) {
    const out = new Uint32Array(w * h);
    const colors = [
      0xFF0000FF, // blue
      0xFF00FF00, // green
      0xFFFF0000, // red
      0xFFFFFFFF, // white
    ];
    const stripeW = (w / 4) | 0;

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const s = Math.min(3, (x / stripeW) | 0); // s represents the stripe index (0-3) 
        out[y * w + x] = colors[s] >>> 0;
      }
    }
    return out;
  }

  // ---------- Futhark loader ----------
  let fut = null;
  let emModule = null;
  let pixelsJsLoaded = false;

  function loadScriptOnce(url) {
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = url;
      s.onload = resolve;
      s.onerror = () => reject(new Error(`Failed to load ${url}`));
      document.head.appendChild(s);
    });
  }

  async function ensureFutharkReady() {
    if (fut) return;

    if (!pixelsJsLoaded) {
      log("Loading pixels.js...");
      await loadScriptOnce("pixels.js"); // generated by futhark webgpu --library -o pixels pixels.fut
      pixelsJsLoaded = true;
      log("pixels.js loaded.");
    }

    if (typeof Module !== "function" || typeof FutharkModule !== "function") {
      throw new Error("pixels.js loaded, but Module/FutharkModule not found (wrong build output?).");
    }

    log("Initializing Emscripten module...");
    emModule = await Module();

    log("Creating Futhark context (WebGPU device)...");
    fut = new FutharkModule();
    await fut.init(emModule);

    log("Futhark ready.");
  }

  async function getPixels() {
    const src = sourceEl.value;

    if (src === "js") {
      return makeARGBStripes(w, h);
    }

    if (src === "js_canvas") {
      // already in canvas word format
      return makeABGRStripes(w, h);
    }

    // src === "futhark"
    await ensureFutharkReady();

    // pixels.fut: entry render (w:i32) (h:i32) : []u32   (ARGB packed)
    const res = await fut.entry.render(w, h);
    const buf = Array.isArray(res) ? res[0] : res;

    const argb = await buf.values(); // Uint32Array
    buf.free();
    return argb;
  }

  // ---------- Render ----------
  async function render() {
    clearLog();
    log(`Endianness: ${little ? "little" : "big"}-endian`);
    log(`Canvas expects RGBA bytes; Uint32 view corresponds to ${little ? "ABGR words (little)" : "RGBA words (big)"}.`);
    log(`Source: ${sourceEl.value}`);

    try {
      const pixels = await getPixels();

      // Raw: write ARGB words directly (wrong)
      drawU32(cRaw, pixels, w, h);

      // Fixed: convert ARGB -> correct canvas word format
      const fixed = new Uint32Array(pixels.length);
      for (let i = 0; i < pixels.length; i++) fixed[i] = argbToCanvasWord(pixels[i]);
      drawU32(cFixed, fixed, w, h);

      log("Rendered both canvases.");

      log("Fixed assumes input is ARGB and applies ARGB->canvas conversion.");
      log("If the source is already canvas-format, Fixed will be wrong (double conversion).");
      
    } catch (e) {
      log("ERROR: " + (e && e.message ? e.message : String(e)));
      if (sourceEl.value === "futhark") {
        log("Did you run `make build` and then serve with `make serve`?");
      }
    }
  }

  // UI wiring
  renderBtn.addEventListener("click", render);
  sourceEl.addEventListener("change", () => {
    if (autoRenderEl.checked) render();
  });

  // Initial render
  render();
}

window.addEventListener("load", run);
